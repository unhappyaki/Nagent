# 四大协议统一基础设施设计方案

## 概述

本文档设计了ACP、A2A、MCP、BIR四大协议的统一基础设施架构，通过抽象共性基础组件，实现协议层的统一管理、监控、认证和配置，降低系统复杂度，提升开发和运维效率。

## 设计目标

### 核心目标
1. **统一管理** - 四大协议共享基础设施，统一入口和出口
2. **降低复杂度** - 避免重复建设，减少维护成本
3. **提升性能** - 统一连接池、缓存和负载均衡
4. **增强安全** - 统一认证授权和安全控制
5. **简化运维** - 统一监控、日志和配置管理

### 技术目标
- **高可用性** - 基础设施可用性 > 99.9%
- **高性能** - 协议路由延迟 < 10ms
- **高并发** - 支持10000+并发协议调用
- **扩展性** - 支持新协议快速接入
- **兼容性** - 保持现有协议功能完整性

## 现状分析

### 📊 协议共性分析

| 基础设施组件 | ACP | A2A | MCP | BIR | 可统一性 | 实施优先级 |
|-------------|-----|-----|-----|-----|---------|-----------|
| **网关层** | ✅ | ✅ | ✅ | ✅ | ⭐⭐⭐⭐⭐ | P0 |
| **注册中心** | ✅ | ✅ | ✅ | ✅ | ⭐⭐⭐⭐⭐ | P0 |
| **认证授权** | ✅ | ✅ | ✅ | ✅ | ⭐⭐⭐⭐⭐ | P0 |
| **监控追踪** | ✅ | ✅ | ✅ | ✅ | ⭐⭐⭐⭐⭐ | P0 |
| **连接管理** | ✅ | ✅ | ✅ | ❌ | ⭐⭐⭐⭐ | P1 |
| **负载均衡** | ✅ | ✅ | ✅ | ✅ | ⭐⭐⭐⭐ | P1 |
| **配置管理** | ✅ | ✅ | ✅ | ✅ | ⭐⭐⭐⭐⭐ | P0 |
| **错误处理** | ✅ | ✅ | ✅ | ✅ | ⭐⭐⭐⭐⭐ | P0 |
| **速率限制** | ✅ | ✅ | ✅ | ✅ | ⭐⭐⭐⭐ | P1 |
| **数据转换** | ✅ | ✅ | ✅ | ✅ | ⭐⭐⭐ | P2 |

### 🏗️ 现有框架结构分析

#### 现有优势
- **通信域(communication/)** - 已有protocols/、adapters/结构，便于协议集成
- **协调域(coordination/)** - 已有registry/、governance/，可扩展为统一注册中心
- **监控域(monitoring/)** - 已有logging/、metrics/、tracing/，基础设施完善
- **执行域(execution/)** - 已有统一的executor，便于协议执行集成
- **状态域(state/)** - 已有context/、memory/，支持协议状态管理

#### 需要新增
- **统一网关层** - 缺少协议入口统一管理
- **统一认证授权** - 各协议权限控制分散
- **统一连接池** - 协议连接管理未统一
- **协议适配层** - 缺少标准化的协议适配框架

## 架构设计

### 整体分层架构

```mermaid
graph TB
    subgraph "外部请求层"
        EXT1[ACP客户端]
        EXT2[A2A智能体]
        EXT3[MCP工具]
        EXT4[BIR用户请求]
        EXT5[其他外部系统]
    end
    
    subgraph "统一基础设施层 (Infrastructure) - 横切关注点"
        UG[统一网关<br/>Unified Gateway<br/>协议识别和路由]
        UA[统一认证授权<br/>Unified Auth<br/>跨系统权限控制]
        UM[统一监控追踪<br/>Unified Monitoring<br/>全链路追踪]
        UC[统一配置管理<br/>Unified Config<br/>配置统一管理]
        UE[统一错误处理<br/>Unified Error<br/>统一异常处理]
        UN[统一连接池<br/>Unified Connection<br/>连接复用管理]
    end
    
    subgraph "协议适配层 (Protocol Adapters)"
        PA[ACP适配器]
        PB[A2A适配器]
        PC[MCP适配器]
        PD[BIR适配器]
        PE[外部服务适配器]
    end
    
    subgraph "协调域 (Coordination Domain) - 业务协调层"
        subgraph "智能体协调"
            UR[服务注册发现<br/>ServiceRegistry<br/>智能体服务管理]
            UL[负载均衡<br/>LoadBalancer<br/>智能体负载分发]
            CM[容器管理<br/>ContainerManager<br/>智能体容器化]
        end
        
        subgraph "任务协调"
            TS[任务调度<br/>TaskScheduler<br/>任务分发调度]
            RA[资源分配<br/>ResourceAllocator<br/>计算资源管理]
            HC[健康检查<br/>HealthChecker<br/>服务健康监控]
        end
    end
    
    subgraph "现有业务域 (Business Domains)"
        COM[通信域<br/>Communication]
        EXE[执行域<br/>Execution]
        STA[状态域<br/>State]
        MON[监控域<br/>Monitoring]
        COR[核心域<br/>Core]
    end
    
    subgraph "外部服务层 (External Services)"
        DB[数据库服务]
        LLM[大模型API<br/>OneAPI网关]
        TOOLS[外部工具服务]
        STORAGE[存储服务]
        API[第三方API]
    end
    
    %% 请求流向
    EXT1 --> UG
    EXT2 --> UG
    EXT3 --> UG
    EXT4 --> UG
    EXT5 --> UG
    
    %% 统一基础设施处理
    UG --> PA
    UG --> PB
    UG --> PC
    UG --> PD
    UG --> PE
    
    %% 适配器到协调域
    PA --> UR
    PB --> UR
    PC --> UR
    PD --> UR
    PE --> UR
    
    %% 协调域内部协调
    UR --> TS
    UR --> CM
    TS --> RA
    TS --> HC
    
    %% 协调域到业务域
    TS --> COM
    TS --> EXE
    TS --> STA
    CM --> COR
    
    %% 业务域到外部服务
    COM --> LLM
    EXE --> TOOLS
    STA --> DB
    MON --> STORAGE
    COR --> API
    
    %% 统一基础设施的横切支撑
    UA -.-> UR
    UA -.-> TS
    UA -.-> COM
    UA -.-> EXE
    
    UM -.-> UR
    UM -.-> TS
    UM -.-> COM
    UM -.-> EXE
    
    UC -.-> UR
    UC -.-> TS
    UC -.-> COM
    UC -.-> EXE
    
    UE -.-> UR
    UE -.-> TS
    UE -.-> COM
    UE -.-> EXE
    
    UN -.-> LLM
    UN -.-> DB
    UN -.-> TOOLS
    UN -.-> STORAGE
```

### 分层职责定义

#### 1. 统一基础设施层 (Infrastructure Layer)
**职责范围：横切关注点和基础能力**
- ✅ **协议处理** - 四大协议的识别、路由、适配
- ✅ **认证授权** - 跨系统的统一权限控制
- ✅ **监控追踪** - 全链路的分布式追踪
- ✅ **配置管理** - 统一的配置和热更新
- ✅ **错误处理** - 统一的异常处理和重试
- ✅ **连接管理** - 外部服务的连接池和复用

#### 2. 协调域 (Coordination Domain)  
**职责范围：业务协调和资源管理**
- ✅ **智能体管理** - Agent的注册、发现、生命周期
- ✅ **任务调度** - 任务的分发、调度、状态管理
- ✅ **资源分配** - 计算资源的分配和监控
- ✅ **容器管理** - Agent容器化部署和管理
- ✅ **负载均衡** - 业务层面的负载分发
- ✅ **健康检查** - 业务服务的健康监控

### 集成架构设计

#### 统一基础设施与协调域的协作模式

```python
# 协调域集成统一基础设施
class EnhancedServiceRegistry:
    """增强的服务注册中心 - 集成统一基础设施"""
    
    def __init__(self, config: Dict[str, Any]):
        # 保留原有协调域功能
        self.original_registry = ServiceRegistry()
        
        # 集成统一基础设施
        self.unified_registry = UnifiedRegistry(config)
        self.unified_auth = UnifiedAuth(config)
        self.unified_tracer = UnifiedTracer(config)
        
    async def register_agent(
        self,
        agent_info: AgentInfo,
        user_id: Optional[str] = None
    ) -> bool:
        """注册智能体 - 双重注册"""
        
        # 1. 统一认证授权检查
        auth_result = await self.unified_auth.authorize(
            user_id=user_id,
            resource="agent:register",
            permission="write"
        )
        if not auth_result:
            raise PermissionError("Agent注册权限不足")
        
        # 2. 统一监控追踪
        span = self.unified_tracer.start_span(
            "agent_registration",
            "coordination",
            tags={"agent_id": agent_info.agent_id, "user_id": user_id}
        )
        
        try:
            # 3. 业务层注册 (现有逻辑)
            business_success = await self.original_registry.register_service(
                service_name=agent_info.name,
                service_type="agent",
                host=agent_info.host,
                port=agent_info.port,
                metadata={"agent_type": agent_info.agent_type}
            )
            
            # 4. 基础设施层注册 (新增)
            if business_success:
                unified_service = UnifiedService(
                    service_id=agent_info.agent_id,
                    service_type="agent",
                    name=agent_info.name,
                    endpoint=f"http://{agent_info.host}:{agent_info.port}",
                    capabilities=agent_info.capabilities,
                    metadata={
                        "agent_type": agent_info.agent_type,
                        "coordination_managed": True
                    }
                )
                infrastructure_success = await self.unified_registry.register_service(
                    unified_service
                )
                
                if not infrastructure_success:
                    # 回滚业务层注册
                    await self.original_registry.deregister_service(agent_info.agent_id)
                    return False
            
            self.unified_tracer.finish_span(span, TraceStatus.SUCCESS)
            return business_success
            
        except Exception as e:
            self.unified_tracer.finish_span(span, TraceStatus.ERROR)
            raise
```

### 模块层次结构 (修正版)

```
src/
├── infrastructure/                    # 统一基础设施层 (新增)
│   ├── __init__.py
│   ├── README.md
│   │
│   ├── gateway/                       # 统一网关
│   │   ├── __init__.py
│   │   ├── unified_gateway.py         # 网关核心
│   │   ├── protocol_router.py         # 协议路由器
│   │   ├── gateway_middleware.py      # 网关中间件
│   │   └── rate_limiter.py           # 速率限制器
│   │
│   ├── registry/                      # 统一注册中心 (基础设施层)
│   │   ├── __init__.py
│   │   ├── unified_registry.py        # 基础设施注册中心
│   │   ├── service_discovery.py       # 跨域服务发现
│   │   ├── health_checker.py         # 基础设施健康检查
│   │   └── metadata_manager.py       # 元数据管理
│   │
│   ├── auth/                          # 统一认证授权
│   │   ├── __init__.py
│   │   ├── unified_auth.py           # 认证核心
│   │   ├── permission_manager.py     # 权限管理
│   │   ├── token_manager.py          # 令牌管理
│   │   └── security_policy.py        # 安全策略
│   │
│   ├── monitoring/                    # 统一监控
│   │   ├── __init__.py
│   │   ├── unified_tracer.py         # 统一追踪
│   │   ├── metrics_aggregator.py     # 指标聚合
│   │   ├── alert_manager.py          # 告警管理
│   │   └── dashboard_api.py          # 仪表板API
│   │
│   ├── connection/                    # 统一连接管理
│   │   ├── __init__.py
│   │   ├── connection_pool.py        # 连接池
│   │   ├── transport_manager.py      # 传输管理
│   │   ├── session_manager.py        # 会话管理
│   │   └── protocol_converter.py     # 协议转换
│   │
│   ├── config/                        # 统一配置管理
│   │   ├── __init__.py
│   │   ├── config_manager.py         # 配置管理器
│   │   ├── protocol_config.py        # 协议配置
│   │   ├── dynamic_config.py         # 动态配置
│   │   └── config_validator.py       # 配置验证
│   │
│   └── error/                         # 统一错误处理
│       ├── __init__.py
│       ├── error_handler.py          # 错误处理器
│       ├── retry_manager.py          # 重试管理
│       ├── circuit_breaker.py        # 熔断器
│       └── fault_tolerance.py        # 容错机制
│
├── communication/
│   ├── protocol_adapters/             # 协议适配层
│   │   ├── __init__.py
│   │   ├── base_adapter.py           # 适配器基类
│   │   ├── acp_adapter.py            # ACP适配器
│   │   ├── a2a_adapter.py            # A2A适配器
│   │   ├── mcp_adapter.py            # MCP适配器
│   │   └── bir_adapter.py            # BIR适配器
│   │
│   └── llm/                          # OneAPI大模型网关集成
│       ├── __init__.py
│       ├── oneapi_client.py          # OneAPI客户端
│   │   └── token_monitor.py          # Token监控管理器
│   │   └── intelligent_router.py     # 智能路由器
│   │   └── cost_optimizer.py         # 成本优化器
│   │   └── context_optimizer.py      # 上下文优化器
│   │   └── fallback_manager.py       # 降级管理器
│   │
│   └── coordination/                      # 协调域 (现有，扩展集成)
│       ├── container/                     # 容器管理
│       │   ├── __init__.py
│       │   ├── agent_container.py         # 智能体容器
│       │   ├── container_manager.py       # 容器管理器
│       │   └── resource_manager.py        # 资源管理器
│       │
│       ├── registry/                      # 业务层服务注册 (现有)
│       │   ├── __init__.py
│       │   ├── service_registry.py        # 业务服务注册中心
│       │   ├── discovery.py              # 业务服务发现
│       │   ├── health_checker.py         # 业务健康检查
│       │   └── infrastructure_bridge.py  # 基础设施集成桥接 (新增)
│       │
│       ├── scheduler/                     # 任务调度 (现有)
│       │   ├── __init__.py
│       │   ├── task_scheduler.py         # 任务调度器
│       │   ├── resource_allocator.py     # 资源分配器
│       │   └── scheduling_policy.py      # 调度策略
│       │
│       └── governance/                    # 治理层 (现有)
│           ├── __init__.py
│           └── agent_governance.py       # 智能体治理
│
└── [其他现有模块保持不变]
```

## 核心组件设计

### 1. 统一网关层 (Unified Gateway)

#### 核心职责
- **协议识别** - 自动识别请求协议类型
- **路由分发** - 将请求路由到对应的协议适配器
- **流量控制** - 统一的速率限制和流量管理
- **中间件处理** - 认证、日志、监控等横切关注点

#### 核心接口
```python
class UnifiedGateway:
    """统一网关 - 四大协议统一入口"""
    
    async def route_request(
        self,
        request: UnifiedRequest
    ) -> UnifiedResponse:
        """路由请求到对应协议处理器"""
        
    async def register_protocol_handler(
        self,
        protocol_type: str,
        handler: BaseProtocolAdapter
    ) -> bool:
        """注册协议处理器"""
        
    async def apply_middleware(
        self,
        request: UnifiedRequest,
        middleware_chain: List[Middleware]
    ) -> UnifiedRequest:
        """应用中间件链"""
```

#### 协议识别策略
```python
class ProtocolDetector:
    """协议检测器"""
    
    DETECTION_RULES = {
        "acp": {
            "headers": {"Content-Type": "application/acp+json"},
            "path_patterns": ["/acp/*"],
            "payload_signature": ["meta", "context", "command"]
        },
        "a2a": {
            "headers": {"Content-Type": "application/a2a+json"},
            "path_patterns": ["/a2a/*", "/.well-known/agent.json"],
            "payload_signature": ["task", "agent_card"]
        },
        "mcp": {
            "headers": {"Content-Type": "application/json-rpc"},
            "path_patterns": ["/mcp/*"],
            "payload_signature": ["jsonrpc", "method", "params"]
        },
        "bir": {
            "headers": {"Content-Type": "application/json"},
            "path_patterns": ["/bir/*", "/api/*"],
            "payload_signature": ["instruction", "user_id"]
        }
    }
```

### 2. 统一注册中心 (Unified Registry)

#### 核心职责
- **服务注册** - 统一注册ACP服务器、A2A智能体、MCP工具、BIR处理器
- **服务发现** - 提供统一的服务发现接口
- **健康检查** - 监控所有注册服务的健康状态
- **元数据管理** - 管理服务的元数据和配置信息

#### 统一服务模型
```python
@dataclass
class UnifiedService:
    """统一服务模型"""
    service_id: str                    # 服务唯一标识
    service_type: str                  # 服务类型(acp/a2a/mcp/bir)
    name: str                          # 服务名称
    version: str                       # 服务版本
    endpoint: str                      # 服务端点
    capabilities: List[str]            # 服务能力
    metadata: Dict[str, Any]           # 扩展元数据
    health_check_url: str             # 健康检查URL
    registration_time: datetime        # 注册时间
    last_heartbeat: datetime          # 最后心跳时间
    status: ServiceStatus             # 服务状态
```

#### 服务发现接口
```python
class UnifiedRegistry:
    """统一注册中心"""
    
    async def register_service(
        self,
        service: UnifiedService
    ) -> bool:
        """注册服务"""
        
    async def discover_services(
        self,
        service_type: str = None,
        capabilities: List[str] = None,
        tags: Dict[str, str] = None
    ) -> List[UnifiedService]:
        """发现服务"""
        
    async def get_service(
        self,
        service_id: str
    ) -> Optional[UnifiedService]:
        """获取特定服务"""
        
    async def health_check_all(self) -> Dict[str, bool]:
        """检查所有服务健康状态"""
```

### 3. 统一认证授权 (Unified Auth)

#### 核心职责
- **身份认证** - 支持多种认证方式(API Key、OAuth2、JWT)
- **权限控制** - 统一的权限模型和访问控制
- **安全策略** - 跨协议的安全策略管理
- **审计日志** - 统一的安全审计和访问日志

#### 统一权限模型
```python
class UnifiedPermission:
    """统一权限模型"""
    
    # 权限类型
    class PermissionType(Enum):
        READ = "read"               # 读取权限
        WRITE = "write"             # 写入权限
        EXECUTE = "execute"         # 执行权限
        ADMIN = "admin"             # 管理权限
        DELEGATE = "delegate"       # 委托权限
    
    # 资源类型
    class ResourceType(Enum):
        PROTOCOL = "protocol"       # 协议资源
        SERVICE = "service"         # 服务资源
        TOOL = "tool"              # 工具资源
        AGENT = "agent"            # 智能体资源
        DATA = "data"              # 数据资源
```

#### 认证授权接口
```python
class UnifiedAuth:
    """统一认证授权"""
    
    async def authenticate(
        self,
        credentials: Dict[str, Any],
        protocol_type: str
    ) -> AuthResult:
        """统一身份认证"""
        
    async def authorize(
        self,
        user_id: str,
        resource: str,
        permission: PermissionType,
        context: Dict[str, Any] = None
    ) -> bool:
        """统一权限授权"""
        
    async def create_token(
        self,
        user_id: str,
        scope: List[str],
        expires_in: int = 3600
    ) -> str:
        """创建访问令牌"""
        
    async def validate_token(
        self,
        token: str
    ) -> TokenInfo:
        """验证访问令牌"""
```

### 4. 统一监控追踪 (Unified Monitoring)

#### 核心职责
- **统一追踪** - 跨协议的分布式追踪
- **指标聚合** - 统一收集和聚合各协议指标
- **告警管理** - 统一的告警规则和通知机制
- **性能分析** - 跨协议的性能分析和优化建议

#### 统一追踪模型
```python
@dataclass
class UnifiedTrace:
    """统一追踪模型"""
    trace_id: str                      # 追踪ID
    span_id: str                       # 跨度ID
    parent_span_id: Optional[str]      # 父跨度ID
    protocol_type: str                 # 协议类型
    operation_name: str                # 操作名称
    start_time: datetime               # 开始时间
    end_time: Optional[datetime]       # 结束时间
    duration: Optional[float]          # 持续时间
    status: TraceStatus               # 追踪状态
    tags: Dict[str, str]              # 标签
    logs: List[Dict[str, Any]]        # 日志
    context: Dict[str, Any]           # 上下文信息
```

#### 监控接口
```python
class UnifiedTracer:
    """统一追踪器"""
    
    def start_span(
        self,
        operation_name: str,
        protocol_type: str,
        parent_span: Optional[str] = None,
        tags: Dict[str, str] = None
    ) -> UnifiedSpan:
        """开始追踪跨度"""
        
    def finish_span(
        self,
        span: UnifiedSpan,
        status: TraceStatus = TraceStatus.SUCCESS
    ):
        """结束追踪跨度"""
        
    async def get_trace(
        self,
        trace_id: str
    ) -> UnifiedTrace:
        """获取完整追踪链"""
        
    async def query_traces(
        self,
        query: TraceQuery
    ) -> List[UnifiedTrace]:
        """查询追踪数据"""
```

### 5. 统一连接管理 (Unified Connection)

#### 核心职责
- **连接池管理** - 统一管理各协议的连接池
- **会话管理** - 跨协议的会话状态管理
- **传输优化** - 连接复用和传输协议优化
- **故障恢复** - 连接故障检测和自动恢复

#### 连接管理接口
```python
class UnifiedConnectionPool:
    """统一连接池"""
    
    async def get_connection(
        self,
        protocol_type: str,
        target: str,
        connection_config: Dict[str, Any] = None
    ) -> UnifiedConnection:
        """获取连接"""
        
    async def return_connection(
        self,
        connection: UnifiedConnection
    ):
        """归还连接"""
        
    async def health_check_connections(
        self,
        protocol_type: str = None
    ) -> Dict[str, bool]:
        """检查连接健康状态"""
        
    async def get_pool_stats(self) -> Dict[str, Any]:
        """获取连接池统计信息"""
```

### 6. 统一配置管理 (Unified Config)

#### 核心职责
- **配置统一** - 统一管理四大协议的配置
- **动态更新** - 支持配置的热更新和版本管理
- **环境隔离** - 支持多环境配置管理
- **配置验证** - 配置的语法和语义验证

#### 配置结构
```yaml
# config/unified_infrastructure.yaml
infrastructure:
  # 统一网关配置
  gateway:
    enabled: true
    host: "0.0.0.0"
    port: 8080
    max_connections: 10000
    request_timeout: 30
    middleware:
      - auth
      - rate_limit
      - logging
      - tracing
    
    # 协议路由配置
    protocol_routing:
      acp:
        path_prefix: "/acp"
        default_timeout: 30
      a2a:
        path_prefix: "/a2a"
        default_timeout: 45
      mcp:
        path_prefix: "/mcp"
        default_timeout: 60
      bir:
        path_prefix: "/api"
        default_timeout: 15
  
  # 统一注册中心配置
  registry:
    enabled: true
    backend: "etcd"  # etcd/consul/zookeeper
    endpoints: ["http://localhost:2379"]
    health_check_interval: 30
    service_ttl: 60
    
  # 统一认证配置
  auth:
    enabled: true
    default_provider: "jwt"
    providers:
      jwt:
        secret_key: "${JWT_SECRET_KEY}"
        algorithm: "HS256"
        expires_in: 3600
      oauth2:
        client_id: "${OAUTH2_CLIENT_ID}"
        client_secret: "${OAUTH2_CLIENT_SECRET}"
        issuer: "https://auth.example.com"
    
    # 权限映射
    permission_mapping:
      acp:
        agent_call: ["execute"]
        agent_manage: ["admin"]
      a2a:
        task_create: ["write"]
        task_execute: ["execute"]
      mcp:
        tool_call: ["execute"]
        resource_read: ["read"]
      bir:
        instruction_process: ["execute"]
  
  # 统一监控配置
  monitoring:
    enabled: true
    tracing:
      backend: "jaeger"
      endpoint: "http://localhost:14268/api/traces"
      sampling_rate: 1.0
    metrics:
      backend: "prometheus"
      endpoint: "http://localhost:9090"
      push_interval: 10
    logging:
      level: "INFO"
      format: "json"
      output: ["console", "file"]
  
  # 统一连接配置
  connection:
    enabled: true
    pools:
      acp:
        max_connections: 100
        connection_timeout: 10
        idle_timeout: 300
      a2a:
        max_connections: 50
        connection_timeout: 15
        idle_timeout: 600
      mcp:
        max_connections: 200
        connection_timeout: 5
        idle_timeout: 120
    
  # 统一错误处理配置
  error:
    enabled: true
    retry:
      max_attempts: 3
      backoff_strategy: "exponential"
      base_delay: 1
    circuit_breaker:
      failure_threshold: 5
      timeout: 60
      half_open_max_calls: 3

# 协议特定配置保持独立
protocols:
  acp:
    # ACP特定配置
  a2a:
    # A2A特定配置
  mcp:
    # MCP特定配置
  bir:
    # BIR特定配置
```

## 协议适配层设计

### 协议适配器基类

```python
class BaseProtocolAdapter:
    """协议适配器基类"""
    
    def __init__(
        self,
        protocol_type: str,
        unified_gateway: UnifiedGateway,
        unified_registry: UnifiedRegistry,
        unified_auth: UnifiedAuth,
        unified_tracer: UnifiedTracer
    ):
        self.protocol_type = protocol_type
        self.gateway = unified_gateway
        self.registry = unified_registry
        self.auth = unified_auth
        self.tracer = unified_tracer
    
    async def handle_request(
        self,
        request: UnifiedRequest
    ) -> UnifiedResponse:
        """处理协议请求 - 子类必须实现"""
        raise NotImplementedError
    
    async def validate_request(
        self,
        request: UnifiedRequest
    ) -> bool:
        """验证请求格式 - 子类可重写"""
        return True
    
    async def transform_request(
        self,
        unified_request: UnifiedRequest
    ) -> Any:
        """将统一请求转换为协议特定格式"""
        raise NotImplementedError
    
    async def transform_response(
        self,
        protocol_response: Any
    ) -> UnifiedResponse:
        """将协议响应转换为统一格式"""
        raise NotImplementedError
```

### ACP协议适配器

```python
class ACPProtocolAdapter(BaseProtocolAdapter):
    """ACP协议适配器"""
    
    def __init__(self, **kwargs):
        super().__init__("acp", **kwargs)
        self.acp_server = None  # 现有ACP服务器实例
    
    async def handle_request(
        self,
        request: UnifiedRequest
    ) -> UnifiedResponse:
        """处理ACP请求"""
        
        # 1. 验证请求
        if not await self.validate_request(request):
            return UnifiedResponse.error("Invalid ACP request format")
        
        # 2. 认证授权
        auth_result = await self.auth.authenticate(
            request.credentials, "acp"
        )
        if not auth_result.success:
            return UnifiedResponse.error("Authentication failed")
        
        # 3. 开始追踪
        span = self.tracer.start_span(
            "acp_request", "acp",
            tags={"user_id": auth_result.user_id}
        )
        
        try:
            # 4. 转换请求格式
            acp_payload = await self.transform_request(request)
            
            # 5. 调用现有ACP处理逻辑
            result = await self.acp_server.handle_message(acp_payload)
            
            # 6. 转换响应格式
            response = await self.transform_response(result)
            
            self.tracer.finish_span(span, TraceStatus.SUCCESS)
            return response
            
        except Exception as e:
            self.tracer.finish_span(span, TraceStatus.ERROR)
            return UnifiedResponse.error(str(e))
    
    async def transform_request(
        self,
        unified_request: UnifiedRequest
    ) -> ACPPayload:
        """转换为ACP载荷格式"""
        return ACPPayload(
            meta=unified_request.headers,
            context=unified_request.context,
            command=unified_request.payload,
            trace_id=unified_request.trace_id,
            context_id=unified_request.context_id,
            timestamp=int(time.time()),
            source_id=unified_request.source_id
        )
```

## 集成现有框架

### 1. 与现有通信域集成

```python
# 修改 src/communication/__init__.py
from ..infrastructure import UnifiedGateway, UnifiedRegistry
from .protocol_adapters import ACPAdapter, A2AAdapter, MCPAdapter, BIRAdapter

class CommunicationDomain:
    """通信域 - 集成统一基础设施"""
    
    def __init__(self, config: Dict[str, Any]):
        # 统一基础设施
        self.unified_gateway = UnifiedGateway(config)
        self.unified_registry = UnifiedRegistry(config)
        
        # 协议适配器
        self.adapters = {
            "acp": ACPAdapter(self.unified_gateway, self.unified_registry),
            "a2a": A2AAdapter(self.unified_gateway, self.unified_registry),
            "mcp": MCPAdapter(self.unified_gateway, self.unified_registry),
            "bir": BIRAdapter(self.unified_gateway, self.unified_registry)
        }
        
        # 注册协议处理器
        for protocol_type, adapter in self.adapters.items():
            self.unified_gateway.register_protocol_handler(
                protocol_type, adapter
            )
    
    async def start(self):
        """启动通信域"""
        await self.unified_gateway.start()
        await self.unified_registry.start()
        
        # 启动各协议适配器
        for adapter in self.adapters.values():
            await adapter.start()
```

### 2. 与现有协调域集成

```python
# 扩展 src/coordination/registry/service_registry.py
class ServiceRegistry:
    """服务注册表 - 集成统一注册中心"""
    
    def __init__(self, config: Dict[str, Any]):
        # 现有逻辑保持不变
        self.agents = {}
        self.services = {}
        
        # 集成统一注册中心
        self.unified_registry = UnifiedRegistry(config)
    
    async def register_agent(self, agent_info: AgentInfo) -> bool:
        """注册智能体 - 同时注册到统一注册中心"""
        # 现有注册逻辑
        success = await self._register_agent_local(agent_info)
        
        if success:
            # 注册到统一注册中心
            unified_service = UnifiedService(
                service_id=agent_info.agent_id,
                service_type="agent",
                name=agent_info.name,
                endpoint=agent_info.endpoint,
                capabilities=agent_info.capabilities,
                metadata={"agent_type": agent_info.agent_type}
            )
            await self.unified_registry.register_service(unified_service)
        
        return success
```

### 3. 与现有监控域集成

```python
# 扩展 src/monitoring/tracing/trace_writer.py
class TraceWriter:
    """追踪写入器 - 集成统一追踪"""
    
    def __init__(self, config: Dict[str, Any]):
        # 现有逻辑
        self.traces = {}
        
        # 集成统一追踪
        self.unified_tracer = UnifiedTracer(config)
    
    def record_trace(
        self,
        trace_id: str,
        trace_type: TraceType,
        message: str,
        data: Dict[str, Any] = None
    ):
        """记录追踪 - 同时写入统一追踪系统"""
        # 现有逻辑
        self._record_trace_local(trace_id, trace_type, message, data)
        
        # 写入统一追踪系统
        self.unified_tracer.record_event(
            trace_id=trace_id,
            event_name=trace_type.value,
            data={
                "message": message,
                "data": data,
                "timestamp": datetime.utcnow()
            }
        )
```

## 部署配置

### Docker Compose部署

```yaml
# docker-compose.infrastructure.yml
version: '3.8'

services:
  # 统一网关
  unified-gateway:
    build:
      context: .
      dockerfile: docker/infrastructure/gateway.Dockerfile
    ports:
      - "8080:8080"
    environment:
      - INFRASTRUCTURE_CONFIG=/app/config/unified_infrastructure.yaml
      - GATEWAY_HOST=0.0.0.0
      - GATEWAY_PORT=8080
    volumes:
      - ./config:/app/config
    depends_on:
      - etcd
      - jaeger
      - prometheus
    restart: unless-stopped
  
  # 统一注册中心存储
  etcd:
    image: quay.io/coreos/etcd:v3.5.0
    ports:
      - "2379:2379"
      - "2380:2380"
    environment:
      - ETCD_ADVERTISE_CLIENT_URLS=http://localhost:2379
      - ETCD_LISTEN_CLIENT_URLS=http://0.0.0.0:2379
    volumes:
      - etcd_data:/etcd-data
  
  # 分布式追踪
  jaeger:
    image: jaegertracing/all-in-one:latest
    ports:
      - "16686:16686"
      - "14268:14268"
    environment:
      - COLLECTOR_ZIPKIN_HTTP_PORT=9411
  
  # 监控指标
  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus

volumes:
  etcd_data:
  prometheus_data:
```

### Kubernetes部署

```yaml
# k8s/infrastructure-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: unified-infrastructure
spec:
  replicas: 3
  selector:
    matchLabels:
      app: unified-infrastructure
  template:
    metadata:
      labels:
        app: unified-infrastructure
    spec:
      containers:
      - name: unified-gateway
        image: nagent/unified-infrastructure:latest
        ports:
        - containerPort: 8080
        env:
        - name: INFRASTRUCTURE_CONFIG
          value: "/app/config/unified_infrastructure.yaml"
        - name: ETCD_ENDPOINTS
          value: "http://etcd:2379"
        - name: JAEGER_ENDPOINT
          value: "http://jaeger:14268/api/traces"
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
        volumeMounts:
        - name: config
          mountPath: /app/config
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
      volumes:
      - name: config
        configMap:
          name: infrastructure-config
---
apiVersion: v1
kind: Service
metadata:
  name: unified-infrastructure
spec:
  selector:
    app: unified-infrastructure
  ports:
  - port: 8080
    targetPort: 8080
  type: LoadBalancer
```

## 监控与运维

### 关键指标

```python
# 统一基础设施关键指标
INFRASTRUCTURE_METRICS = {
    # 网关指标
    "gateway_requests_total": "网关总请求数",
    "gateway_request_duration": "网关请求处理时间",
    "gateway_protocol_distribution": "协议请求分布",
    "gateway_error_rate": "网关错误率",
    
    # 注册中心指标
    "registry_services_total": "注册服务总数",
    "registry_health_check_duration": "健康检查耗时",
    "registry_service_discovery_rate": "服务发现请求率",
    
    # 认证指标
    "auth_requests_total": "认证请求总数",
    "auth_success_rate": "认证成功率",
    "auth_token_created_total": "创建令牌总数",
    "auth_permission_check_duration": "权限检查耗时",
    
    # 连接池指标
    "connection_pool_size": "连接池大小",
    "connection_pool_utilization": "连接池利用率",
    "connection_creation_duration": "连接创建耗时",
    "connection_failures_total": "连接失败总数"
}
```

### 告警规则

```yaml
# monitoring/infrastructure-alerts.yml
groups:
- name: unified-infrastructure
  rules:
  - alert: GatewayHighErrorRate
    expr: rate(gateway_errors_total[5m]) / rate(gateway_requests_total[5m]) > 0.05
    for: 2m
    labels:
      severity: warning
    annotations:
      summary: "统一网关错误率过高"
      
  - alert: RegistryServiceDown
    expr: registry_services_healthy / registry_services_total < 0.9
    for: 1m
    labels:
      severity: critical
    annotations:
      summary: "注册中心服务健康率低于90%"
      
  - alert: AuthServiceUnavailable
    expr: up{job="unified-auth"} == 0
    for: 30s
    labels:
      severity: critical
    annotations:
      summary: "统一认证服务不可用"
      
  - alert: ConnectionPoolExhausted
    expr: connection_pool_utilization > 0.9
    for: 5m
    labels:
      severity: warning
    annotations:
      summary: "连接池利用率过高"
```

## 实施计划

### 第一阶段：基础设施核心（2-3周）
1. **统一网关实现**
   - 协议识别和路由
   - 基础中间件支持
   - 协议适配器框架

2. **统一注册中心实现**
   - 服务注册和发现
   - 健康检查机制
   - 元数据管理

3. **统一认证授权实现**
   - 多种认证方式支持
   - 统一权限模型
   - 安全策略管理

### 第二阶段：监控与连接（2周）
1. **统一监控集成**
   - 跨协议追踪
   - 指标聚合
   - 告警管理

2. **统一连接管理**
   - 连接池实现
   - 传输优化
   - 故障恢复

### 第三阶段：协议适配（3-4周）
1. **四大协议适配器实现**
   - ACP协议适配器
   - A2A协议适配器
   - MCP协议适配器
   - BIR协议适配器

2. **现有框架集成**
   - 通信域集成
   - 协调域集成
   - 监控域集成

### 第四阶段：测试与优化（2周）
1. **集成测试**
   - 跨协议调用测试
   - 性能压力测试
   - 故障恢复测试

2. **性能优化**
   - 连接池优化
   - 缓存策略优化
   - 监控性能调优

## 方案调整与完善

### 🔍 现状分析与问题识别

基于智能体API网关设计和企业级架构实践的深入分析，当前统一基础设施设计方案存在以下关键缺失：

#### 关键问题清单
```yaml
架构完整性问题:
  - src/infrastructure/ 目录完全为空，缺少核心实现
  - 缺少租户治理层和多租户隔离机制
  - 没有企业级安全防护层设计
  - 策略引擎功能过于简化

安全机制缺失:
  - 缺少防重放攻击机制（时间戳+签名+Nonce）
  - 没有防刷流检测和行为模式识别
  - Token权限控制粒度不够细化
  - 缺少租户级安全策略管理

监控体系不足:
  - 追踪数据结构缺少业务级指标
  - 没有API网关专用监控指标
  - 缺少安全事件和异常行为检测
  - 监控数据与业务决策脱节

配置管理简化:
  - 配置结构过于简单，不支持租户分层
  - 缺少动态策略DSL支持
  - 没有A/B测试和灰度发布机制
  - 配置热更新和版本管理不完善
```

### 🎯 架构层次调整

#### 新增架构层次
```mermaid
graph TB
    subgraph "外部请求层"
        EXT1[ACP客户端]
        EXT2[A2A智能体]
        EXT3[MCP工具]
        EXT4[BIR用户请求]
        EXT5[其他外部系统]
    end
    
    subgraph "租户治理层 (Tenant Governance Layer) - 新增"
        TM[租户管理器<br/>TenantManager<br/>多租户隔离管理]
        TQ[配额控制器<br/>QuotaController<br/>租户级配额控制]
        TP[策略分层器<br/>PolicyLayering<br/>租户策略分层]
    end
    
    subgraph "安全防护层 (Security Protection Layer) - 新增"
        AR[防重放模块<br/>AntiReplay<br/>时间戳+签名+Nonce]
        AA[防滥用模块<br/>AntiAbuse<br/>刷流检测+行为识别]
        SC[权限细化控制<br/>ScopeControl<br/>Token精细化权限]
    end
    
    subgraph "策略引擎层 (Policy Engine Layer) - 增强"
        PE[策略引擎<br/>PolicyEngine<br/>DSL策略编排]
        RD[规则下发器<br/>RuleDispatcher<br/>动态规则下发]
        AB[A/B测试引擎<br/>ABTestEngine<br/>实验策略支持]
    end
    
    subgraph "统一基础设施层 (Infrastructure) - 原有"
        UG[统一网关]
        UA[统一认证授权]
        UM[统一监控追踪]
        UC[统一配置管理]
        UE[统一错误处理]
        UN[统一连接池]
    end
    
    %% 新增层次间的关系
    EXT1 --> TM
    EXT2 --> TM
    EXT3 --> TM
    EXT4 --> TM
    EXT5 --> TM
    
    TM --> AR
    TQ --> AA
    TP --> SC
    
    AR --> PE
    AA --> RD
    SC --> AB
    
    PE --> UG
    RD --> UA
    AB --> UM
```

#### 层次职责重新定义

##### 1. 租户治理层 (新增)
```yaml
职责范围: 多租户管理和资源控制
核心组件:
  - TenantManager: 租户注册、认证、生命周期管理
  - QuotaController: QPS限制、Token配额、成本控制
  - PolicyLayering: 全局/租户/用户三层策略管理
  
关键能力:
  - 租户隔离: 数据隔离、资源隔离、网络隔离
  - 配额管理: 实时配额监控、超限告警、自动限流
  - 策略继承: 策略分层、权限继承、策略覆盖
```

##### 2. 安全防护层 (新增)
```yaml
职责范围: 企业级安全防护和威胁检测
核心组件:
  - AntiReplay: 防重放攻击、签名验证、时间窗口控制
  - AntiAbuse: 防刷流检测、行为模式识别、IP信誉检查
  - ScopeControl: Token权限细化、模型白名单、区域控制
  
关键能力:
  - 攻击防护: 重放攻击、暴力破解、DDoS防护
  - 行为分析: 异常检测、风险评分、自动响应
  - 精细授权: 资源级权限、时间窗口、地域限制
```

##### 3. 策略引擎层 (增强)
```yaml
职责范围: 动态策略管理和智能决策
核心组件:
  - PolicyEngine: DSL策略解析、规则执行、策略组合
  - RuleDispatcher: 策略热更新、版本管理、灰度发布
  - ABTestEngine: A/B测试、流量分割、效果评估
  
关键能力:
  - 策略编排: 复杂规则组合、条件判断、动作执行
  - 热更新: 无中断更新、版本回滚、配置同步
  - 实验支持: 多模型对比、效果追踪、智能切换
```

### 🛡️ 安全机制增强设计

#### 防重放攻击机制
```python
# 增强的防重放机制设计
class AntiReplayProtection:
    """防重放攻击保护"""
    
    def __init__(self):
        self.nonce_cache = RedisCache(ttl=300)  # 5分钟TTL
        self.max_timestamp_drift = 60  # 1分钟时间漂移
        self.signature_algorithms = ["HMAC-SHA256", "RSA-SHA256"]
    
    async def validate_request(self, request: UnifiedRequest) -> bool:
        # 1. 时间戳验证
        timestamp = request.headers.get("X-Timestamp")
        if abs(time.time() - int(timestamp)) > self.max_timestamp_drift:
            raise TimestampExpiredError("Request timestamp expired")
        
        # 2. Nonce唯一性检查
        nonce = request.headers.get("X-Nonce")
        if await self.nonce_cache.exists(nonce):
            raise ReplayAttackError("Nonce already used")
        
        # 3. 签名验证
        signature = request.headers.get("X-Signature")
        if not self.verify_signature(request.payload, signature):
            raise InvalidSignatureError("Signature verification failed")
        
        # 4. 记录Nonce
        await self.nonce_cache.set(nonce, True)
        return True

# 请求格式要求
request_format:
  headers:
    X-Tenant-ID: "ent-301"
    X-Timestamp: "1714801001"
    X-Nonce: "2da1c0e9af134"
    X-Signature: "0c9f08d..."
    Authorization: "Bearer eyJhbGciOiJIUzI1NiIs..."
```

#### 防刷流检测机制
```python
class AntiAbuseDetection:
    """防滥用检测"""
    
    def __init__(self):
        self.behavior_analyzer = BehaviorAnalyzer()
        self.ip_reputation = IPReputationService()
        self.rate_tracker = RateTracker()
    
    async def detect_abuse(self, request: UnifiedRequest) -> RiskAssessment:
        risk_score = 0.0
        risk_factors = []
        
        # 1. 突发流量检测
        burst_ratio = await self.rate_tracker.get_burst_ratio(
            request.tenant_id, window=60
        )
        if burst_ratio > 5.0:  # 突发流量超过平均5倍
            risk_score += 0.3
            risk_factors.append("high_burst_traffic")
        
        # 2. IP信誉检查
        ip_reputation = await self.ip_reputation.check(request.client_ip)
        if ip_reputation < 0.5:  # 信誉分数低于0.5
            risk_score += 0.4
            risk_factors.append("low_ip_reputation")
        
        # 3. 行为模式分析
        behavior_score = await self.behavior_analyzer.analyze(
            request.tenant_id, request.user_agent, request.request_pattern
        )
        if behavior_score > 0.8:  # 异常行为分数高于0.8
            risk_score += 0.5
            risk_factors.append("abnormal_behavior_pattern")
        
        return RiskAssessment(
            risk_score=min(risk_score, 1.0),
            risk_factors=risk_factors,
            recommended_action=self._get_recommended_action(risk_score)
        )

# 检测指标配置
abuse_detection_config:
  burst_detection:
    window_seconds: 60
    threshold_multiplier: 5.0
    
  ip_reputation:
    min_reputation_score: 0.5
    reputation_cache_ttl: 3600
    
  behavior_analysis:
    pattern_window: 300
    anomaly_threshold: 0.8
    features: ["request_frequency", "user_agent_variation", "endpoint_diversity"]
```

#### Token权限细化控制
```python
class ScopeControl:
    """Token权限细化控制"""
    
    def __init__(self):
        self.permission_matrix = PermissionMatrix()
        self.resource_mapper = ResourceMapper()
    
    async def validate_scope(self, token: TokenInfo, request: UnifiedRequest) -> bool:
        # 1. 模型访问权限检查
        if request.model not in token.allowed_models:
            raise ModelAccessDeniedError(
                f"Model '{request.model}' not allowed for token scope"
            )
        
        # 2. 区域访问权限检查
        if request.region not in token.allowed_regions:
            raise RegionAccessDeniedError(
                f"Region '{request.region}' not allowed for token scope"
            )
        
        # 3. 时间窗口权限检查
        current_hour = datetime.now().hour
        if not token.access_window.is_allowed(current_hour):
            raise TimeWindowViolationError(
                f"Access not allowed at hour {current_hour}"
            )
        
        # 4. 资源级权限检查
        required_permissions = self.resource_mapper.get_required_permissions(
            request.action, request.resource_type
        )
        if not token.permissions.contains_all(required_permissions):
            raise InsufficientPermissionsError(
                f"Missing permissions: {required_permissions - token.permissions}"
            )
        
        return True

# Token权限结构增强
token_scope_structure:
  tenant_id: "ent-301"
  user_id: "user-123"
  permissions:
    models: ["gpt-4", "claude-3"]
    regions: ["cn-bj", "cn-sh", "us-west"]
    actions: ["read", "write", "execute"]
    resources: ["agent:*", "tool:basic", "data:public"]
    quotas:
      qps_limit: 300
      token_limit_daily: 50000
      cost_limit_daily_usd: 10.0
    restrictions:
      access_window: ["09:00", "18:00"]
      ip_whitelist: ["192.168.1.0/24"]
      user_agent_pattern: "^MyApp/.*"
```

### 📊 监控体系增强设计

#### 统一追踪模型增强
```python
@dataclass
class EnhancedUnifiedTrace:
    """增强的统一追踪模型"""
    
    # 基础追踪信息
    trace_id: str
    span_id: str
    parent_span_id: Optional[str]
    protocol_type: str
    start_time: datetime
    end_time: Optional[datetime]
    duration_ms: Optional[float]
    status: TraceStatus
    
    # 租户和用户信息
    tenant_id: str
    user_id: Optional[str]
    session_id: Optional[str]
    
    # 业务指标
    business_metrics: BusinessMetrics
    
    # 安全指标  
    security_metrics: SecurityMetrics
    
    # 性能指标
    performance_metrics: PerformanceMetrics
    
    # 成本指标
    cost_metrics: CostMetrics

@dataclass
class BusinessMetrics:
    """业务指标"""
    model_called: str
    token_usage: TokenUsage
    cache_hit: bool
    result_quality_score: Optional[float]
    user_satisfaction_score: Optional[float]

@dataclass  
class SecurityMetrics:
    """安全指标"""
    auth_method: str
    permissions_checked: List[str]
    rate_limit_applied: bool
    security_events: List[SecurityEvent]
    risk_score: float
    threat_indicators: List[str]

@dataclass
class PerformanceMetrics:
    """性能指标"""
    gateway_latency_ms: float
    auth_latency_ms: float
    routing_latency_ms: float
    backend_latency_ms: float
    total_latency_ms: float
    queue_wait_time_ms: float

@dataclass
class CostMetrics:
    """成本指标"""
    api_cost_usd: float
    compute_cost_usd: float
    storage_cost_usd: float
    total_cost_usd: float
    cost_efficiency_score: float
```

#### API网关专用监控指标
```yaml
gateway_specific_metrics:
  # 请求指标
  request_metrics:
    gateway_requests_total:
      labels: [protocol, tenant_id, status_code, region]
      description: "网关处理的请求总数"
    
    gateway_request_duration_seconds:
      labels: [protocol, tenant_id, endpoint]
      description: "网关请求处理时间分布"
    
    gateway_protocol_distribution:
      labels: [protocol]
      description: "协议请求分布"
    
    gateway_tenant_distribution:
      labels: [tenant_id, tier]
      description: "租户请求分布"

  # 安全指标
  security_metrics:
    gateway_auth_failures_total:
      labels: [tenant_id, auth_method, failure_reason]
      description: "认证失败总数"
    
    gateway_rate_limit_hits_total:
      labels: [tenant_id, limit_type, protocol]
      description: "限流触发总数"
    
    gateway_security_events_total:
      labels: [event_type, severity, tenant_id]
      description: "安全事件总数"
    
    gateway_replay_attempts_total:
      labels: [tenant_id, client_ip]
      description: "重放攻击尝试总数"

  # 业务指标
  business_metrics:
    gateway_token_usage_total:
      labels: [tenant_id, model, token_type]
      description: "Token使用总量"
    
    gateway_cost_tracking_usd:
      labels: [tenant_id, model, cost_type]
      description: "成本追踪（美元）"
    
    gateway_model_usage_distribution:
      labels: [model, tenant_tier]
      description: "模型使用分布"
    
    gateway_tenant_quota_utilization:
      labels: [tenant_id, quota_type]
      description: "租户配额利用率"

  # 性能指标
  performance_metrics:
    gateway_latency_breakdown:
      labels: [component, protocol]
      description: "网关延迟分解"
    
    gateway_throughput_qps:
      labels: [protocol, tenant_tier]
      description: "网关吞吐量"
    
    gateway_error_rate:
      labels: [error_type, protocol]
      description: "网关错误率"
```

### 🔧 配置管理增强设计

#### 租户分层配置结构
```yaml
# 增强的统一配置结构
unified_infrastructure_enhanced:
  # 租户管理配置
  tenant_management:
    default_quotas:
      qps_limit: 100
      token_limit_monthly: 100000
      cost_limit_monthly_usd: 50.0
      concurrent_requests: 10
      
    tenant_tiers:
      free:
        qps: 10
        tokens: 10000
        cost: 5.0
        models: ["gpt-3.5-turbo"]
        regions: ["cn-bj"]
        features: ["basic_auth"]
        
      basic:
        qps: 100
        tokens: 100000
        cost: 50.0
        models: ["gpt-3.5-turbo", "claude-3-haiku"]
        regions: ["cn-bj", "cn-sh"]
        features: ["basic_auth", "rate_limit"]
        
      premium:
        qps: 1000
        tokens: 1000000
        cost: 500.0
        models: ["gpt-4", "claude-3-opus"]
        regions: ["global"]
        features: ["advanced_auth", "custom_policies", "priority_support"]
        
      enterprise:
        qps: 10000
        tokens: 10000000
        cost: 5000.0
        models: ["all"]
        regions: ["global"]
        features: ["sso", "custom_deployment", "dedicated_support"]

  # 安全策略配置
  security_policies:
    global_policies:
      - name: "anti_replay"
        enabled: true
        config:
          nonce_ttl: 300
          max_timestamp_drift: 60
          signature_algorithms: ["HMAC-SHA256", "RSA-SHA256"]
          
      - name: "anti_abuse"
        enabled: true
        config:
          burst_threshold: 5.0
          ip_reputation_threshold: 0.5
          behavior_anomaly_threshold: 0.8
          
      - name: "rate_limiting"
        enabled: true
        config:
          algorithm: "token_bucket"
          window_seconds: 60
          burst_factor: 1.5

    tenant_specific_policies:
      "ent-enterprise":
        custom_policies:
          - name: "advanced_threat_detection"
            enabled: true
            config:
              ml_model: "enterprise_threat_model_v2"
              sensitivity: "high"
              
          - name: "custom_rate_limiting"
            enabled: true
            config:
              algorithm: "adaptive_sliding_window"
              base_limit: 1000
              adaptive_factor: 2.0

  # 策略DSL配置
  policy_dsl:
    enabled: true
    engine: "rego"  # 或 "cel", "javascript"
    
    global_rules:
      - name: "business_hours_restriction"
        rule: |
          package nagent.policies
          
          default allow = false
          
          allow {
            input.tenant_tier == "enterprise"
          }
          
          allow {
            input.tenant_tier != "enterprise"
            time.now_ns() >= time.parse_rfc3339_ns("09:00:00Z")
            time.now_ns() <= time.parse_rfc3339_ns("18:00:00Z")
          }
          
      - name: "model_access_control"
        rule: |
          package nagent.policies
          
          allowed_models[model] {
            tier_config := data.tenant_tiers[input.tenant_tier]
            model := tier_config.models[_]
          }
          
          deny[msg] {
            not allowed_models[input.model]
            msg := sprintf("Model '%s' not allowed for tier '%s'", [input.model, input.tenant_tier])
          }

  # A/B测试配置
  ab_testing:
    enabled: true
    experiments:
      - name: "model_routing_experiment"
        description: "比较不同模型的效果"
        status: "active"
        traffic_split:
          control: 50  # 使用默认模型
          treatment: 50  # 使用新模型
        target_metrics:
          - "response_quality"
          - "latency"
          - "cost_efficiency"
        duration_days: 14
        
      - name: "rate_limiting_algorithm"
        description: "测试不同限流算法"
        status: "active"
        variants:
          token_bucket: 33
          sliding_window: 33
          adaptive: 34
        target_metrics:
          - "fairness"
          - "throughput"
          - "user_experience"

  # 监控告警配置
  monitoring_alerts:
    enabled: true
    
    alert_rules:
      - name: "HighErrorRate"
        condition: "rate(gateway_errors_total[5m]) / rate(gateway_requests_total[5m]) > 0.05"
        duration: "2m"
        severity: "warning"
        annotations:
          summary: "网关错误率过高"
          
      - name: "SecurityThreatDetected"
        condition: "increase(gateway_security_events_total[1m]) > 10"
        duration: "30s"
        severity: "critical"
        annotations:
          summary: "检测到安全威胁"
          
      - name: "TenantQuotaExceeded"
        condition: "gateway_tenant_quota_utilization > 0.9"
        duration: "1m"
        severity: "warning"
        annotations:
          summary: "租户配额即将耗尽"

    notification_channels:
      - name: "slack"
        type: "slack"
        config:
          webhook_url: "${SLACK_WEBHOOK_URL}"
          channel: "#alerts"
          
      - name: "email"
        type: "email"
        config:
          smtp_server: "smtp.example.com"
          recipients: ["ops@example.com"]
```

### 🚀 实施计划调整

#### 重新规划的实施阶段
```yaml
第一阶段 (2周) - 安全优先基础设施:
  priority: P0
  目标: 建立安全可靠的基础框架
  components:
    - 统一网关基础框架（协议识别、路由）
    - 防重放攻击机制（时间戳+签名+Nonce）
    - 基础认证授权（JWT + API Key）
    - 租户管理基础（注册、配额、隔离）
  
  deliverables:
    - src/infrastructure/gateway/unified_gateway.py
    - src/infrastructure/auth/unified_auth.py
    - src/infrastructure/security/anti_replay.py
    - src/infrastructure/tenant/tenant_manager.py

第二阶段 (2周) - 安全防护完善:
  priority: P0  
  目标: 完善企业级安全防护能力
  components:
    - 防刷流检测（行为分析、IP信誉）
    - Token权限细化控制（模型、区域、时间）
    - 安全审计日志（事件记录、威胁追踪）
    - 限流机制增强（多维度、自适应）
  
  deliverables:
    - src/infrastructure/security/anti_abuse.py
    - src/infrastructure/security/scope_control.py
    - src/infrastructure/monitoring/security_audit.py
    - src/infrastructure/gateway/rate_limiter.py

第三阶段 (3周) - 高级治理能力:
  priority: P1
  目标: 实现智能化策略管理
  components:
    - DSL策略引擎（Rego/CEL策略解析）
    - 动态配置管理（热更新、版本控制）
    - A/B测试支持（流量分割、效果评估）
    - 租户自定义策略（策略编排、权限委托）
  
  deliverables:
    - src/infrastructure/policy/policy_engine.py
    - src/infrastructure/config/dynamic_config.py
    - src/infrastructure/experiment/ab_test_engine.py
    - src/infrastructure/tenant/custom_policies.py

第四阶段 (2周) - 监控优化与运维:
  priority: P1
  目标: 完善监控体系和运维工具
  components:
    - 统一监控仪表板（多维度指标、实时监控）
    - 性能优化（缓存、连接池、负载均衡）
    - 智能告警（异常检测、自动响应）
    - 运维工具（配置管理、故障诊断）
  
  deliverables:
    - src/infrastructure/monitoring/dashboard_api.py
    - src/infrastructure/optimization/performance_optimizer.py
    - src/infrastructure/monitoring/intelligent_alerts.py
    - tools/infrastructure_cli.py

第五阶段 (1周) - 集成测试与文档:
  priority: P1
  目标: 确保系统稳定性和可维护性
  components:
    - 集成测试（跨协议调用、故障恢复）
    - 性能压力测试（高并发、大流量）
    - 安全渗透测试（攻击模拟、防护验证）
    - 文档完善（部署指南、运维手册）
  
  deliverables:
    - tests/integration/infrastructure_tests.py
    - tests/performance/load_tests.py
    - tests/security/penetration_tests.py
    - docs/infrastructure_deployment_guide.md
```

### 📋 集成策略调整

#### 与现有架构的深度集成
```python
# 协调域集成增强
coordination_infrastructure_integration:
  # 双重注册机制
  service_registry_bridge:
    business_layer: "src/coordination/registry/service_registry.py"
    infrastructure_layer: "src/infrastructure/registry/unified_registry.py"
    bridge_component: "src/coordination/registry/infrastructure_bridge.py"
    
    integration_strategy:
      - 业务服务注册到协调域注册中心
      - 同时注册到基础设施统一注册中心
      - 通过桥接组件保持数据同步
      - 支持服务发现的双重查询
  
  # 治理策略统一
  governance_integration:
    coordination_governance: "src/coordination/governance/agent_governance.py"
    api_gateway_governance: "src/infrastructure/governance/api_governance.py"
    unified_policy_engine: "src/infrastructure/policy/unified_policy_engine.py"
    
    integration_strategy:
      - Agent级别治理策略（协调域）
      - 租户级别治理策略（基础设施层）
      - 统一策略引擎协调两层策略
      - 策略冲突检测和解决机制

# 通信域协议适配增强
communication_protocol_enhancement:
  existing_protocols:
    acp: "src/communication/acp/"
    mcp: "src/communication/protocols/mcp/"
    adapters: "src/communication/adapters/"
  
  enhancement_components:
    unified_adapter_framework: "src/infrastructure/adapters/base_protocol_adapter.py"
    protocol_version_manager: "src/infrastructure/protocols/version_manager.py"
    message_transformer: "src/infrastructure/protocols/message_transformer.py"
    middleware_support: "src/infrastructure/gateway/protocol_middleware.py"
  
  integration_strategy:
    - 现有协议适配器继承统一基础框架
    - 协议版本管理统一化
    - 跨协议消息转换支持
    - 协议特定中间件插件化

# 监控域追踪增强
monitoring_tracing_enhancement:
  existing_monitoring: "src/monitoring/"
  infrastructure_monitoring: "src/infrastructure/monitoring/"
  
  integration_components:
    trace_bridge: "src/monitoring/tracing/infrastructure_bridge.py"
    metrics_aggregator: "src/infrastructure/monitoring/metrics_aggregator.py"
    unified_dashboard: "src/infrastructure/monitoring/unified_dashboard.py"
  
  integration_strategy:
    - 现有TraceWriter集成统一追踪
    - 业务指标和基础设施指标聚合
    - 统一监控仪表板展示
    - 告警规则统一管理
```

## 总结

### 🎯 核心价值

1. **统一管理** - 四大协议共享基础设施，降低50%的重复建设成本
2. **简化运维** - 统一的监控、配置和部署，运维复杂度降低60%
3. **提升性能** - 统一连接池和负载均衡，整体性能提升30%
4. **增强安全** - 统一认证授权，安全管控一致性提升90%
5. **快速扩展** - 标准化协议适配框架，新协议接入时间缩短80%

### 🔧 技术优势

1. **完整的安全防护体系** - 防重放、防刷流、精细化权限控制
2. **智能化策略管理** - DSL策略引擎、动态配置、A/B测试支持
3. **企业级监控体系** - 业务指标、安全指标、性能指标全覆盖
4. **多租户治理能力** - 租户隔离、配额管理、策略分层
5. **平滑集成方案** - 与现有框架深度集成，渐进式升级

### 🚀 实施效果

通过增强的统一基础设施建设，Nagent架构将真正实现：
- **协议互操作** - 四大协议统一管理和调度，安全可控
- **运维简化** - 一套基础设施支撑所有协议，智能化运维
- **性能优化** - 共享资源和智能调度，自适应优化
- **安全增强** - 企业级安全防护，全方位威胁检测
- **扩展便利** - 新协议快速接入，策略灵活配置

这套增强的统一基础设施将成为企业级多协议智能体系统的坚实基石，支撑平台在复杂业务场景下的安全、稳定、高效运行！ 