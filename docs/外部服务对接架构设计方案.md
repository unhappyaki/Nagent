# å¤–éƒ¨æœåŠ¡å¯¹æ¥æ¶æ„è®¾è®¡æ–¹æ¡ˆ

## é¡¹ç›®æ¦‚è¿°

æœ¬æ–¹æ¡ˆè®¾è®¡äº†ä¸€ä¸ªç»Ÿä¸€çš„å¤–éƒ¨æœåŠ¡å¯¹æ¥æ¶æ„ï¼Œç”¨äºé›†æˆå„ç§å¤–éƒ¨æœåŠ¡ï¼ˆå¦‚Unstructuredæ–‡æ¡£è§£æã€GraphRAGçŸ¥è¯†å›¾è°±ã€å‘é‡æ•°æ®åº“ã€LLMæœåŠ¡ç­‰ï¼‰ï¼Œæä¾›ç»Ÿä¸€çš„æ¥å£ã€è¿æ¥ç®¡ç†ã€æ•…éšœå¤„ç†å’Œç›‘æ§èƒ½åŠ›ã€‚

## æ•´ä½“æ¶æ„è®¾è®¡

### æ ¸å¿ƒæ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           Application Layer åº”ç”¨å±‚                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Knowledge       â”‚  â”‚ Query Engine    â”‚  â”‚ Workflow        â”‚  â”‚ User Interface  â”‚ â”‚
â”‚  â”‚ Manager         â”‚  â”‚                 â”‚  â”‚ Engine          â”‚  â”‚                 â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                        â”‚
                                        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Service Integration Layer æœåŠ¡é›†æˆå±‚                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Service         â”‚  â”‚ Connection      â”‚  â”‚ Circuit         â”‚  â”‚ Load            â”‚ â”‚
â”‚  â”‚ Gateway         â”‚  â”‚ Pool Manager    â”‚  â”‚ Breaker         â”‚  â”‚ Balancer        â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Retry Manager   â”‚  â”‚ Cache Manager   â”‚  â”‚ Health Monitor  â”‚  â”‚ Metrics         â”‚ â”‚
â”‚  â”‚                 â”‚  â”‚                 â”‚  â”‚                 â”‚  â”‚ Collector       â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                        â”‚
                                        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        Service Adapter Layer æœåŠ¡é€‚é…å±‚                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Document        â”‚  â”‚ Knowledge       â”‚  â”‚ Vector          â”‚  â”‚ LLM             â”‚ â”‚
â”‚  â”‚ Processing      â”‚  â”‚ Graph           â”‚  â”‚ Database        â”‚  â”‚ Services        â”‚ â”‚
â”‚  â”‚ Adapter         â”‚  â”‚ Adapter         â”‚  â”‚ Adapter         â”‚  â”‚ Adapter         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                        â”‚
                                        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         External Services å¤–éƒ¨æœåŠ¡å±‚                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Unstructured    â”‚  â”‚ Microsoft       â”‚  â”‚ Chroma/Pinecone â”‚  â”‚ OpenAI/Claude   â”‚ â”‚
â”‚  â”‚ Document API    â”‚  â”‚ GraphRAG API    â”‚  â”‚ Vector DB API   â”‚  â”‚ LLM APIs        â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## æ ¸å¿ƒç»„ä»¶è®¾è®¡

### 1. ç»Ÿä¸€æœåŠ¡ç½‘å…³ (Service Gateway)

```python
# src/communication/external/service_gateway.py
from typing import Dict, List, Optional, Any, Union
from enum import Enum
import asyncio
import logging
from dataclasses import dataclass
from datetime import datetime

class ServiceType(Enum):
    """å¤–éƒ¨æœåŠ¡ç±»å‹"""
    DOCUMENT_PROCESSING = "document_processing"
    KNOWLEDGE_GRAPH = "knowledge_graph"
    VECTOR_DATABASE = "vector_database"
    LLM_SERVICE = "llm_service"
    EMBEDDING_SERVICE = "embedding_service"

@dataclass
class ServiceConfig:
    """æœåŠ¡é…ç½®"""
    service_id: str
    service_type: ServiceType
    name: str
    base_url: str
    api_key: Optional[str] = None
    timeout: int = 30
    max_retries: int = 3
    retry_delay: float = 1.0
    circuit_breaker_threshold: int = 5
    health_check_interval: int = 60
    metadata: Dict[str, Any] = None

@dataclass
class ServiceRequest:
    """æœåŠ¡è¯·æ±‚"""
    service_id: str
    method: str
    endpoint: str
    data: Optional[Dict[str, Any]] = None
    files: Optional[Dict[str, Any]] = None
    headers: Optional[Dict[str, str]] = None
    timeout: Optional[int] = None

@dataclass
class ServiceResponse:
    """æœåŠ¡å“åº”"""
    success: bool
    status_code: int
    data: Any
    error_message: Optional[str] = None
    response_time: float = 0.0
    service_id: str = ""

class ServiceGateway:
    """ç»Ÿä¸€æœåŠ¡ç½‘å…³"""
    
    def __init__(self):
        self.services: Dict[str, ServiceConfig] = {}
        self.adapters: Dict[str, 'BaseServiceAdapter'] = {}
        self.connection_pool = ConnectionPoolManager()
        self.circuit_breaker = CircuitBreakerManager()
        self.retry_manager = RetryManager()
        self.cache_manager = CacheManager()
        self.health_monitor = HealthMonitor()
        self.metrics_collector = MetricsCollector()
        self.logger = logging.getLogger(__name__)
    
    async def register_service(self, config: ServiceConfig, adapter: 'BaseServiceAdapter'):
        """æ³¨å†Œå¤–éƒ¨æœåŠ¡"""
        self.services[config.service_id] = config
        self.adapters[config.service_id] = adapter
        
        # åˆå§‹åŒ–é€‚é…å™¨
        await adapter.initialize(config)
        
        # å¯åŠ¨å¥åº·æ£€æŸ¥
        await self.health_monitor.start_monitoring(config.service_id)
        
        self.logger.info(f"Service registered: {config.service_id}")
    
    async def call_service(
        self,
        service_id: str,
        method: str,
        endpoint: str,
        data: Optional[Dict[str, Any]] = None,
        **kwargs
    ) -> ServiceResponse:
        """è°ƒç”¨å¤–éƒ¨æœåŠ¡"""
        
        # æ£€æŸ¥æœåŠ¡æ˜¯å¦æ³¨å†Œ
        if service_id not in self.services:
            return ServiceResponse(
                success=False,
                status_code=404,
                data=None,
                error_message=f"Service {service_id} not registered",
                service_id=service_id
            )
        
        # æ£€æŸ¥ç†”æ–­å™¨çŠ¶æ€
        if self.circuit_breaker.is_open(service_id):
            return ServiceResponse(
                success=False,
                status_code=503,
                data=None,
                error_message=f"Circuit breaker is open for service {service_id}",
                service_id=service_id
            )
        
        # æ„å»ºè¯·æ±‚
        request = ServiceRequest(
            service_id=service_id,
            method=method,
            endpoint=endpoint,
            data=data,
            **kwargs
        )
        
        # æ£€æŸ¥ç¼“å­˜
        cache_key = self._generate_cache_key(request)
        cached_response = await self.cache_manager.get(cache_key)
        if cached_response:
            self.metrics_collector.record_cache_hit(service_id)
            return cached_response
        
        # æ‰§è¡Œè¯·æ±‚ï¼ˆå¸¦é‡è¯•æœºåˆ¶ï¼‰
        response = await self.retry_manager.execute_with_retry(
            self._execute_request,
            request,
            max_retries=self.services[service_id].max_retries
        )
        
        # ç¼“å­˜å“åº”
        if response.success:
            await self.cache_manager.set(cache_key, response)
            self.circuit_breaker.record_success(service_id)
        else:
            self.circuit_breaker.record_failure(service_id)
        
        # è®°å½•æŒ‡æ ‡
        self.metrics_collector.record_request(service_id, response)
        
        return response
    
    async def _execute_request(self, request: ServiceRequest) -> ServiceResponse:
        """æ‰§è¡Œå…·ä½“çš„æœåŠ¡è¯·æ±‚"""
        adapter = self.adapters[request.service_id]
        start_time = asyncio.get_event_loop().time()
        
        try:
            result = await adapter.call(
                method=request.method,
                endpoint=request.endpoint,
                data=request.data,
                files=request.files,
                headers=request.headers,
                timeout=request.timeout
            )
            
            response_time = asyncio.get_event_loop().time() - start_time
            
            return ServiceResponse(
                success=True,
                status_code=200,
                data=result,
                response_time=response_time,
                service_id=request.service_id
            )
            
        except Exception as e:
            response_time = asyncio.get_event_loop().time() - start_time
            
            return ServiceResponse(
                success=False,
                status_code=500,
                data=None,
                error_message=str(e),
                response_time=response_time,
                service_id=request.service_id
            )
    
    def _generate_cache_key(self, request: ServiceRequest) -> str:
        """ç”Ÿæˆç¼“å­˜é”®"""
        import hashlib
        key_data = f"{request.service_id}:{request.method}:{request.endpoint}:{str(request.data)}"
        return hashlib.md5(key_data.encode()).hexdigest()
    
    async def get_service_status(self, service_id: str) -> Dict[str, Any]:
        """è·å–æœåŠ¡çŠ¶æ€"""
        if service_id not in self.services:
            return {"error": "Service not found"}
        
        return {
            "service_id": service_id,
            "health_status": await self.health_monitor.get_status(service_id),
            "circuit_breaker_status": self.circuit_breaker.get_status(service_id),
            "metrics": self.metrics_collector.get_metrics(service_id)
        }
    
    async def get_all_services_status(self) -> Dict[str, Any]:
        """è·å–æ‰€æœ‰æœåŠ¡çŠ¶æ€"""
        statuses = {}
        for service_id in self.services:
            statuses[service_id] = await self.get_service_status(service_id)
        return statuses
```

### 2. åŸºç¡€æœåŠ¡é€‚é…å™¨

```python
# src/communication/external/base_service_adapter.py
from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Any
import aiohttp
import asyncio
from dataclasses import dataclass

class BaseServiceAdapter(ABC):
    """åŸºç¡€æœåŠ¡é€‚é…å™¨"""
    
    def __init__(self):
        self.config: Optional[ServiceConfig] = None
        self.session: Optional[aiohttp.ClientSession] = None
        self._initialized = False
    
    async def initialize(self, config: ServiceConfig):
        """åˆå§‹åŒ–é€‚é…å™¨"""
        self.config = config
        
        # åˆ›å»ºHTTPä¼šè¯
        timeout = aiohttp.ClientTimeout(total=config.timeout)
        self.session = aiohttp.ClientSession(
            timeout=timeout,
            headers=self._get_default_headers()
        )
        
        self._initialized = True
        await self._post_initialize()
    
    async def _post_initialize(self):
        """å­ç±»å¯é‡å†™çš„åˆå§‹åŒ–åå¤„ç†"""
        pass
    
    def _get_default_headers(self) -> Dict[str, str]:
        """è·å–é»˜è®¤è¯·æ±‚å¤´"""
        headers = {
            "User-Agent": "Nagent-ServiceGateway/1.0",
            "Content-Type": "application/json"
        }
        
        if self.config and self.config.api_key:
            headers["Authorization"] = f"Bearer {self.config.api_key}"
        
        return headers
    
    @abstractmethod
    async def call(
        self,
        method: str,
        endpoint: str,
        data: Optional[Dict[str, Any]] = None,
        files: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        timeout: Optional[int] = None
    ) -> Any:
        """è°ƒç”¨æœåŠ¡API"""
        pass
    
    @abstractmethod
    async def health_check(self) -> bool:
        """å¥åº·æ£€æŸ¥"""
        pass
    
    async def close(self):
        """å…³é—­é€‚é…å™¨"""
        if self.session:
            await self.session.close()
        self._initialized = False
    
    def is_initialized(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦å·²åˆå§‹åŒ–"""
        return self._initialized

# HTTPæœåŠ¡é€‚é…å™¨
class HTTPServiceAdapter(BaseServiceAdapter):
    """HTTPæœåŠ¡é€‚é…å™¨"""
    
    async def call(
        self,
        method: str,
        endpoint: str,
        data: Optional[Dict[str, Any]] = None,
        files: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        timeout: Optional[int] = None
    ) -> Any:
        """è°ƒç”¨HTTPæœåŠ¡"""
        
        if not self._initialized:
            raise RuntimeError("Adapter not initialized")
        
        url = f"{self.config.base_url.rstrip('/')}/{endpoint.lstrip('/')}"
        
        # åˆå¹¶è¯·æ±‚å¤´
        request_headers = self._get_default_headers()
        if headers:
            request_headers.update(headers)
        
        # å¤„ç†æ–‡ä»¶ä¸Šä¼ 
        if files:
            # å¯¹äºæ–‡ä»¶ä¸Šä¼ ï¼Œä¸è®¾ç½®Content-Typeï¼Œè®©aiohttpè‡ªåŠ¨å¤„ç†
            request_headers.pop("Content-Type", None)
            
            form_data = aiohttp.FormData()
            if data:
                for key, value in data.items():
                    form_data.add_field(key, str(value))
            
            for key, file_data in files.items():
                if isinstance(file_data, tuple):
                    filename, content = file_data
                    form_data.add_field(key, content, filename=filename)
                else:
                    form_data.add_field(key, file_data)
            
            data = form_data
        
        # æ‰§è¡Œè¯·æ±‚
        async with self.session.request(
            method=method.upper(),
            url=url,
            json=data if not files else None,
            data=data if files else None,
            headers=request_headers,
            timeout=aiohttp.ClientTimeout(total=timeout or self.config.timeout)
        ) as response:
            
            if response.status >= 400:
                error_text = await response.text()
                raise Exception(f"HTTP {response.status}: {error_text}")
            
            # æ ¹æ®å†…å®¹ç±»å‹è§£æå“åº”
            content_type = response.headers.get('Content-Type', '').lower()
            
            if 'application/json' in content_type:
                return await response.json()
            elif 'text/' in content_type:
                return await response.text()
            else:
                return await response.read()
    
    async def health_check(self) -> bool:
        """HTTPå¥åº·æ£€æŸ¥"""
        try:
            # å°è¯•è®¿é—®æ ¹è·¯å¾„æˆ–å¥åº·æ£€æŸ¥ç«¯ç‚¹
            health_endpoints = ['/health', '/status', '/ping', '/']
            
            for endpoint in health_endpoints:
                try:
                    async with self.session.get(
                        f"{self.config.base_url}{endpoint}",
                        timeout=aiohttp.ClientTimeout(total=5)
                    ) as response:
                        if response.status < 500:
                            return True
                except:
                    continue
            
            return False
            
        except Exception:
            return False
```

### 3. å…·ä½“æœåŠ¡é€‚é…å™¨å®ç°

```python
# src/communication/external/adapters/unstructured_adapter.py
from typing import Dict, List, Optional, Any
from ..base_service_adapter import HTTPServiceAdapter

class UnstructuredAdapter(HTTPServiceAdapter):
    """Unstructuredæ–‡æ¡£è§£ææœåŠ¡é€‚é…å™¨"""
    
    async def parse_document(
        self,
        file_content: bytes,
        filename: str,
        strategy: str = "hi_res",
        **kwargs
    ) -> Dict[str, Any]:
        """è§£ææ–‡æ¡£"""
        
        files = {
            'files': (filename, file_content)
        }
        
        data = {
            'strategy': strategy,
            'extract_images_in_pdf': kwargs.get('extract_images', True),
            'infer_table_structure': kwargs.get('infer_tables', True),
            'ocr_languages': kwargs.get('ocr_languages', 'eng,chi_sim')
        }
        
        result = await self.call(
            method='POST',
            endpoint='/general/v0/general',
            data=data,
            files=files
        )
        
        return self._process_unstructured_response(result)
    
    def _process_unstructured_response(self, response: List[Dict]) -> Dict[str, Any]:
        """å¤„ç†Unstructuredå“åº”"""
        processed_doc = {
            "title": "",
            "sections": [],
            "tables": [],
            "images": [],
            "metadata": {
                "total_elements": len(response),
                "parsed_at": datetime.utcnow().isoformat()
            }
        }
        
        current_section = None
        
        for element in response:
            element_type = element.get("type", "")
            text = element.get("text", "").strip()
            
            if element_type == "Title" and not processed_doc["title"]:
                processed_doc["title"] = text
                
            elif element_type in ["Title", "Header"]:
                current_section = {
                    "title": text,
                    "content": [],
                    "level": self._get_header_level(element)
                }
                processed_doc["sections"].append(current_section)
                
            elif element_type == "Table":
                processed_doc["tables"].append({
                    "content": text,
                    "html": element.get("metadata", {}).get("text_as_html", ""),
                    "page_number": element.get("metadata", {}).get("page_number")
                })
                
            elif element_type in ["NarrativeText", "ListItem", "Text"]:
                if current_section:
                    current_section["content"].append(text)
                else:
                    if not processed_doc["sections"]:
                        processed_doc["sections"].append({
                            "title": "Content",
                            "content": [],
                            "level": 1
                        })
                    processed_doc["sections"][0]["content"].append(text)
        
        return processed_doc
    
    def _get_header_level(self, element: Dict) -> int:
        """æ¨æ–­æ ‡é¢˜å±‚çº§"""
        metadata = element.get("metadata", {})
        return metadata.get("header_level", 1)

# src/communication/external/adapters/graphrag_adapter.py
class GraphRAGAdapter(HTTPServiceAdapter):
    """Microsoft GraphRAGæœåŠ¡é€‚é…å™¨"""
    
    async def build_knowledge_graph(
        self,
        documents: List[Dict[str, Any]],
        config: Optional[Dict] = None
    ) -> Dict[str, Any]:
        """æ„å»ºçŸ¥è¯†å›¾è°±"""
        
        payload = {
            "documents": documents,
            "config": config or {
                "chunk_size": 300,
                "chunk_overlap": 100,
                "community_algorithm": "leiden",
                "entity_extraction_model": "gpt-4",
                "relation_extraction_model": "gpt-4"
            }
        }
        
        return await self.call(
            method='POST',
            endpoint='/api/v1/build_graph',
            data=payload
        )
    
    async def query_graph(
        self,
        query: str,
        query_type: str = "global",
        config: Optional[Dict] = None
    ) -> Dict[str, Any]:
        """æŸ¥è¯¢çŸ¥è¯†å›¾è°±"""
        
        payload = {
            "query": query,
            "query_type": query_type,
            "config": config or {
                "max_tokens": 4000,
                "community_level": 2,
                "max_depth": 2
            }
        }
        
        return await self.call(
            method='POST',
            endpoint='/api/v1/query',
            data=payload
        )

# src/communication/external/adapters/vector_db_adapter.py
class VectorDBAdapter(HTTPServiceAdapter):
    """å‘é‡æ•°æ®åº“é€‚é…å™¨"""
    
    async def create_collection(
        self,
        collection_name: str,
        metadata: Optional[Dict] = None
    ) -> Dict[str, Any]:
        """åˆ›å»ºé›†åˆ"""
        
        payload = {
            "name": collection_name,
            "metadata": metadata or {}
        }
        
        return await self.call(
            method='POST',
            endpoint='/api/v1/collections',
            data=payload
        )
    
    async def add_documents(
        self,
        collection_name: str,
        documents: List[str],
        embeddings: List[List[float]],
        metadatas: List[Dict],
        ids: List[str]
    ) -> Dict[str, Any]:
        """æ·»åŠ æ–‡æ¡£"""
        
        payload = {
            "documents": documents,
            "embeddings": embeddings,
            "metadatas": metadatas,
            "ids": ids
        }
        
        return await self.call(
            method='POST',
            endpoint=f'/api/v1/collections/{collection_name}/add',
            data=payload
        )
    
    async def search_similar(
        self,
        collection_name: str,
        query_embedding: List[float],
        n_results: int = 10,
        where: Optional[Dict] = None
    ) -> Dict[str, Any]:
        """ç›¸ä¼¼æ€§æœç´¢"""
        
        payload = {
            "query_embeddings": [query_embedding],
            "n_results": n_results,
            "where": where
        }
        
        return await self.call(
            method='POST',
            endpoint=f'/api/v1/collections/{collection_name}/query',
            data=payload
        )
```

### 4. è¿æ¥æ± ç®¡ç†å™¨

```python
# src/communication/external/connection_pool_manager.py
import asyncio
from typing import Dict, Optional
import aiohttp

class ConnectionPoolManager:
    """è¿æ¥æ± ç®¡ç†å™¨"""
    
    def __init__(self):
        self.pools: Dict[str, aiohttp.ClientSession] = {}
        self.pool_configs: Dict[str, Dict] = {}
    
    async def create_pool(
        self,
        service_id: str,
        base_url: str,
        max_connections: int = 100,
        max_connections_per_host: int = 30,
        timeout: int = 30
    ) -> aiohttp.ClientSession:
        """åˆ›å»ºè¿æ¥æ± """
        
        connector = aiohttp.TCPConnector(
            limit=max_connections,
            limit_per_host=max_connections_per_host,
            keepalive_timeout=60,
            enable_cleanup_closed=True
        )
        
        timeout_config = aiohttp.ClientTimeout(total=timeout)
        
        session = aiohttp.ClientSession(
            connector=connector,
            timeout=timeout_config,
            base_url=base_url
        )
        
        self.pools[service_id] = session
        self.pool_configs[service_id] = {
            "max_connections": max_connections,
            "max_connections_per_host": max_connections_per_host,
            "timeout": timeout
        }
        
        return session
    
    def get_pool(self, service_id: str) -> Optional[aiohttp.ClientSession]:
        """è·å–è¿æ¥æ± """
        return self.pools.get(service_id)
    
    async def close_pool(self, service_id: str):
        """å…³é—­è¿æ¥æ± """
        if service_id in self.pools:
            await self.pools[service_id].close()
            del self.pools[service_id]
            del self.pool_configs[service_id]
    
    async def close_all_pools(self):
        """å…³é—­æ‰€æœ‰è¿æ¥æ± """
        for service_id in list(self.pools.keys()):
            await self.close_pool(service_id)
    
    def get_pool_stats(self, service_id: str) -> Dict:
        """è·å–è¿æ¥æ± ç»Ÿè®¡ä¿¡æ¯"""
        if service_id not in self.pools:
            return {}
        
        session = self.pools[service_id]
        connector = session.connector
        
        return {
            "service_id": service_id,
            "total_connections": len(connector._conns),
            "available_connections": len(connector._available_connections),
            "config": self.pool_configs.get(service_id, {})
        }
```

### 5. ç†”æ–­å™¨ç®¡ç†å™¨

```python
# src/communication/external/circuit_breaker_manager.py
from typing import Dict
from datetime import datetime, timedelta
from enum import Enum

class CircuitBreakerState(Enum):
    CLOSED = "closed"
    OPEN = "open"
    HALF_OPEN = "half_open"

class CircuitBreaker:
    """ç†”æ–­å™¨"""
    
    def __init__(
        self,
        failure_threshold: int = 5,
        timeout: int = 60,
        success_threshold: int = 3
    ):
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.success_threshold = success_threshold
        
        self.failure_count = 0
        self.success_count = 0
        self.last_failure_time = None
        self.state = CircuitBreakerState.CLOSED
    
    def record_success(self):
        """è®°å½•æˆåŠŸ"""
        if self.state == CircuitBreakerState.HALF_OPEN:
            self.success_count += 1
            if self.success_count >= self.success_threshold:
                self._reset()
        elif self.state == CircuitBreakerState.CLOSED:
            self.failure_count = 0
    
    def record_failure(self):
        """è®°å½•å¤±è´¥"""
        self.failure_count += 1
        self.last_failure_time = datetime.utcnow()
        
        if self.failure_count >= self.failure_threshold:
            self.state = CircuitBreakerState.OPEN
    
    def can_execute(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦å¯ä»¥æ‰§è¡Œè¯·æ±‚"""
        if self.state == CircuitBreakerState.CLOSED:
            return True
        elif self.state == CircuitBreakerState.OPEN:
            if self._should_attempt_reset():
                self.state = CircuitBreakerState.HALF_OPEN
                self.success_count = 0
                return True
            return False
        else:  # HALF_OPEN
            return True
    
    def _should_attempt_reset(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦åº”è¯¥å°è¯•é‡ç½®"""
        if self.last_failure_time is None:
            return True
        
        return datetime.utcnow() - self.last_failure_time > timedelta(seconds=self.timeout)
    
    def _reset(self):
        """é‡ç½®ç†”æ–­å™¨"""
        self.failure_count = 0
        self.success_count = 0
        self.state = CircuitBreakerState.CLOSED
    
    def get_status(self) -> Dict:
        """è·å–ç†”æ–­å™¨çŠ¶æ€"""
        return {
            "state": self.state.value,
            "failure_count": self.failure_count,
            "success_count": self.success_count,
            "last_failure_time": self.last_failure_time.isoformat() if self.last_failure_time else None
        }

class CircuitBreakerManager:
    """ç†”æ–­å™¨ç®¡ç†å™¨"""
    
    def __init__(self):
        self.circuit_breakers: Dict[str, CircuitBreaker] = {}
    
    def get_or_create_breaker(
        self,
        service_id: str,
        failure_threshold: int = 5,
        timeout: int = 60,
        success_threshold: int = 3
    ) -> CircuitBreaker:
        """è·å–æˆ–åˆ›å»ºç†”æ–­å™¨"""
        
        if service_id not in self.circuit_breakers:
            self.circuit_breakers[service_id] = CircuitBreaker(
                failure_threshold=failure_threshold,
                timeout=timeout,
                success_threshold=success_threshold
            )
        
        return self.circuit_breakers[service_id]
    
    def is_open(self, service_id: str) -> bool:
        """æ£€æŸ¥ç†”æ–­å™¨æ˜¯å¦å¼€å¯"""
        breaker = self.get_or_create_breaker(service_id)
        return not breaker.can_execute()
    
    def record_success(self, service_id: str):
        """è®°å½•æˆåŠŸ"""
        breaker = self.get_or_create_breaker(service_id)
        breaker.record_success()
    
    def record_failure(self, service_id: str):
        """è®°å½•å¤±è´¥"""
        breaker = self.get_or_create_breaker(service_id)
        breaker.record_failure()
    
    def get_status(self, service_id: str) -> Dict:
        """è·å–ç†”æ–­å™¨çŠ¶æ€"""
        if service_id not in self.circuit_breakers:
            return {"state": "closed", "failure_count": 0}
        
        return self.circuit_breakers[service_id].get_status()
```

## ä½¿ç”¨ç¤ºä¾‹

### æœåŠ¡æ³¨å†Œå’Œè°ƒç”¨

```python
# ç¤ºä¾‹ï¼šæ³¨å†Œå’Œä½¿ç”¨å¤–éƒ¨æœåŠ¡
async def setup_external_services():
    """è®¾ç½®å¤–éƒ¨æœåŠ¡"""
    
    # åˆ›å»ºæœåŠ¡ç½‘å…³
    gateway = ServiceGateway()
    
    # æ³¨å†ŒUnstructuredæœåŠ¡
    unstructured_config = ServiceConfig(
        service_id="unstructured",
        service_type=ServiceType.DOCUMENT_PROCESSING,
        name="Unstructured Document Processing",
        base_url="http://unstructured-api:8000",
        api_key="your-api-key",
        timeout=300,
        max_retries=3
    )
    
    unstructured_adapter = UnstructuredAdapter()
    await gateway.register_service(unstructured_config, unstructured_adapter)
    
    # æ³¨å†ŒGraphRAGæœåŠ¡
    graphrag_config = ServiceConfig(
        service_id="graphrag",
        service_type=ServiceType.KNOWLEDGE_GRAPH,
        name="Microsoft GraphRAG",
        base_url="http://graphrag-api:8001",
        timeout=600,
        max_retries=2
    )
    
    graphrag_adapter = GraphRAGAdapter()
    await gateway.register_service(graphrag_config, graphrag_adapter)
    
    return gateway

# ä½¿ç”¨æœåŠ¡
async def process_document_example():
    """æ–‡æ¡£å¤„ç†ç¤ºä¾‹"""
    
    gateway = await setup_external_services()
    
    # è¯»å–æ–‡æ¡£
    with open("document.pdf", "rb") as f:
        file_content = f.read()
    
    # è°ƒç”¨Unstructuredè§£ææ–‡æ¡£
    response = await gateway.call_service(
        service_id="unstructured",
        method="parse_document",
        endpoint="",  # åœ¨é€‚é…å™¨ä¸­å¤„ç†
        data={
            "file_content": file_content,
            "filename": "document.pdf",
            "strategy": "hi_res"
        }
    )
    
    if response.success:
        parsed_doc = response.data
        
        # ä½¿ç”¨è§£æç»“æœæ„å»ºçŸ¥è¯†å›¾è°±
        graph_response = await gateway.call_service(
            service_id="graphrag",
            method="build_knowledge_graph",
            endpoint="",
            data={
                "documents": [parsed_doc],
                "config": {"chunk_size": 300}
            }
        )
        
        if graph_response.success:
            print("Knowledge graph built successfully!")
        else:
            print(f"Graph building failed: {graph_response.error_message}")
    else:
        print(f"Document parsing failed: {response.error_message}")
```

## é…ç½®æ–‡ä»¶

```yaml
# config/external_services.yaml
external_services:
  # å…¨å±€é…ç½®
  global:
    default_timeout: 30
    default_retries: 3
    circuit_breaker_threshold: 5
    health_check_interval: 60
    
  # æœåŠ¡é…ç½®
  services:
    unstructured:
      service_type: "document_processing"
      name: "Unstructured Document Processing"
      base_url: "${UNSTRUCTURED_API_URL}"
      api_key: "${UNSTRUCTURED_API_KEY}"
      timeout: 300
      max_retries: 3
      circuit_breaker_threshold: 5
      metadata:
        supported_formats: ["pdf", "docx", "xlsx", "pptx", "html"]
        
    graphrag:
      service_type: "knowledge_graph"
      name: "Microsoft GraphRAG"
      base_url: "${GRAPHRAG_API_URL}"
      api_key: "${GRAPHRAG_API_KEY}"
      timeout: 600
      max_retries: 2
      circuit_breaker_threshold: 3
      
    chroma:
      service_type: "vector_database"
      name: "Chroma Vector Database"
      base_url: "${CHROMA_API_URL}"
      timeout: 60
      max_retries: 3
      
    openai:
      service_type: "llm_service"
      name: "OpenAI API"
      base_url: "https://api.openai.com/v1"
      api_key: "${OPENAI_API_KEY}"
      timeout: 60
      max_retries: 3

# è¿æ¥æ± é…ç½®
connection_pools:
  default:
    max_connections: 100
    max_connections_per_host: 30
    keepalive_timeout: 60
    
# ç¼“å­˜é…ç½®
cache:
  enabled: true
  ttl:
    document_parsing: 86400  # 24å°æ—¶
    graph_query: 3600       # 1å°æ—¶
    vector_search: 1800     # 30åˆ†é’Ÿ
    
# ç›‘æ§é…ç½®
monitoring:
  metrics_enabled: true
  health_check_enabled: true
  logging_level: "INFO"
```

## æ€»ç»“

è¿™ä¸ªå¤–éƒ¨æœåŠ¡å¯¹æ¥æ¶æ„è®¾è®¡æä¾›äº†ï¼š

### ğŸ¯ **æ ¸å¿ƒç‰¹æ€§**
1. **ç»Ÿä¸€æ¥å£**ï¼šæ‰€æœ‰å¤–éƒ¨æœåŠ¡é€šè¿‡ç»Ÿä¸€çš„ServiceGatewayè°ƒç”¨
2. **æ™ºèƒ½è·¯ç”±**ï¼šæ ¹æ®æœåŠ¡ç±»å‹å’Œè´Ÿè½½è‡ªåŠ¨è·¯ç”±è¯·æ±‚
3. **æ•…éšœå¤„ç†**ï¼šç†”æ–­å™¨ã€é‡è¯•æœºåˆ¶ã€é™çº§ç­–ç•¥
4. **è¿æ¥ç®¡ç†**ï¼šè¿æ¥æ± ç®¡ç†ï¼Œæé«˜æ€§èƒ½å’Œèµ„æºåˆ©ç”¨ç‡
5. **ç›‘æ§å‘Šè­¦**ï¼šå®Œæ•´çš„ç›‘æ§æŒ‡æ ‡å’Œå¥åº·æ£€æŸ¥

### ğŸ”§ **æŠ€æœ¯ä¼˜åŠ¿**
1. **é«˜å¯ç”¨æ€§**ï¼šå¤šå±‚æ•…éšœå¤„ç†æœºåˆ¶
2. **é«˜æ€§èƒ½**ï¼šè¿æ¥æ± ã€ç¼“å­˜ã€å¼‚æ­¥å¤„ç†
3. **æ˜“æ‰©å±•**ï¼šæ’ä»¶åŒ–é€‚é…å™¨è®¾è®¡
4. **æ˜“ç»´æŠ¤**ï¼šç»Ÿä¸€çš„é…ç½®å’Œç®¡ç†ç•Œé¢
5. **æ˜“æµ‹è¯•**ï¼šæ¨¡å—åŒ–è®¾è®¡ï¼Œä¾¿äºå•å…ƒæµ‹è¯•

è¿™ä¸ªæ¶æ„è®©æˆ‘ä»¬èƒ½å¤Ÿè½»æ¾é›†æˆå„ç§å¤–éƒ¨æœåŠ¡ï¼ŒåŒæ—¶ä¿æŒç³»ç»Ÿçš„ç¨³å®šæ€§å’Œé«˜æ€§èƒ½ï¼ 